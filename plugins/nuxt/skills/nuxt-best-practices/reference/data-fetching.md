# Nuxt 4 Data Fetching Best Practices

Complete guide to data fetching strategies in Nuxt 4 using `useFetch`, `useAsyncData`, and `$fetch`.

## Table of Contents

- [Overview](#overview)
- [Nuxt 4 Changes](#nuxt-4-changes)
- [useFetch](#usefetch)
- [useAsyncData](#useasyncdata)
- [$fetch](#fetch)
- [Error Handling](#error-handling)
- [Caching & Refetching](#caching--refetching)
- [Advanced Patterns](#advanced-patterns)

## Overview

Nuxt provides three primary methods for data fetching:

| Method | Use Case | SSR | Auto Key | Reactive |
|--------|----------|-----|----------|----------|
| `useFetch` | Simple API calls | ✅ | ✅ | ✅ |
| `useAsyncData` | Custom logic | ✅ | ❌ | ✅ |
| `$fetch` | Client-only, manual | ❌ | N/A | ❌ |

## Nuxt 4 Changes

Nuxt 4 introduces significant improvements to data fetching:

### Singleton Data Fetching Layer

- **Shared refs**: All calls with the same key share `data`, `error`, and `status` refs
- **Consistent options**: Calls with the same key must have consistent `deep`, `transform`, `pick`, `getCachedData`, and `default` options
- **Memory management**: Data is automatically cleaned up when the last component unmounts

### Shallow Reactivity

- **Performance**: `data` is now a `shallowRef` by default for better performance with deeply nested objects
- **Opt-in deep**: Use `deep: true` option when you need deep reactivity

### Default Values

- **Undefined defaults**: `data` and `error` now default to `undefined` instead of `null`
- **Type safety**: Better TypeScript inference with proper undefined handling

### Reactive Keys

- **Dynamic keys**: Support for computed refs, plain refs, and getter functions as keys
- **Automatic refetch**: Data automatically refetches when reactive keys change

## useFetch

Best for straightforward API calls with automatic SSR support.

### Basic Usage

```typescript
// ✅ Simplest form - auto-generated key
const { data, error, pending } = await useFetch('/api/users')

// ✅ With query parameters
const { data } = await useFetch('/api/users', {
  query: { page: 1, limit: 10 }
})

// ✅ POST request
const { data } = await useFetch('/api/users', {
  method: 'POST',
  body: { name: 'John', email: 'john@example.com' }
})
```

### Reactive Parameters

Parameters automatically trigger refetch when changed.

```typescript
const page = ref(1)
const limit = ref(10)

// Automatically refetches when page or limit changes
const { data } = await useFetch('/api/users', {
  query: { page, limit }
})

// Change triggers refetch
page.value = 2  // Automatically fetches page 2
```

### Data Transformation

```typescript
// ✅ Transform response data
const { data } = await useFetch('/api/users', {
  transform: (users) => users.map(user => ({
    id: user.id,
    fullName: `${user.firstName} ${user.lastName}`,
    email: user.email
  }))
})

// ✅ Pick specific fields
const { data } = await useFetch('/api/user/profile', {
  pick: ['name', 'email', 'avatar']
})
```

### TypeScript Support

```typescript
interface User {
  id: string
  name: string
  email: string
}

// ✅ Type-safe response
const { data } = await useFetch<User[]>('/api/users')
// data is Ref<User[] | null>

// ✅ With transform
const { data } = await useFetch<User[], string[]>('/api/users', {
  transform: (users) => users.map(u => u.name)
})
// data is Ref<string[] | null>
```

### Options Reference

```typescript
const { data, error, pending, refresh } = await useFetch('/api/users', {
  // Request options
  method: 'GET',
  query: { page: 1 },
  body: null,
  headers: { 'Authorization': 'Bearer token' },

  // Behavior options
  server: true,        // Fetch on SSR (default: true)
  lazy: false,         // Don't block navigation (default: false)
  immediate: true,     // Fetch immediately (default: true)
  watch: [],           // Additional reactive deps to watch

  // Response handling
  transform: (data) => data,
  pick: ['id', 'name'],
  default: () => [],   // Default value while loading

  // Caching
  key: 'users',        // Cache key (auto-generated by default)
  getCachedData: (key) => useNuxtData(key).data.value,

  // Error handling
  onRequest: ({ options }) => {},
  onResponse: ({ response }) => {},
  onRequestError: ({ error }) => {},
  onResponseError: ({ response }) => {}
})
```

## useAsyncData

For custom fetching logic or multiple data sources.

### Basic Usage

```typescript
// ✅ Custom fetcher with explicit key
const { data } = await useAsyncData('users', async () => {
  const response = await $fetch('/api/users')
  return response.data
})

// ✅ Multiple data sources
const { data } = await useAsyncData('dashboard', async () => {
  const [users, posts, stats] = await Promise.all([
    $fetch('/api/users'),
    $fetch('/api/posts'),
    $fetch('/api/stats')
  ])

  return { users, posts, stats }
})
```

### With Custom Logic

```typescript
// ✅ Complex data processing
const { data } = await useAsyncData('user-analytics', async () => {
  const user = await $fetch(`/api/users/${userId}`)
  const activities = await $fetch(`/api/users/${userId}/activities`)

  // Custom processing
  const analytics = processActivities(activities)

  return {
    user,
    totalActivities: activities.length,
    analytics
  }
})
```

### Conditional Fetching

```typescript
const userId = ref<string | null>(null)

// Only fetch when userId is available
const { data } = await useAsyncData(
  'user',
  () => $fetch(`/api/users/${userId.value}`),
  {
    watch: [userId],
    immediate: false  // Don't fetch immediately
  }
)

// Trigger fetch when userId becomes available
watch(userId, (newId) => {
  if (newId) {
    refresh()
  }
})
```

### TypeScript Support

```typescript
interface DashboardData {
  users: User[]
  posts: Post[]
  stats: Stats
}

const { data } = await useAsyncData<DashboardData>(
  'dashboard',
  async () => {
    const [users, posts, stats] = await Promise.all([
      $fetch<User[]>('/api/users'),
      $fetch<Post[]>('/api/posts'),
      $fetch<Stats>('/api/stats')
    ])
    return { users, posts, stats }
  }
)
// data is Ref<DashboardData | null>
```

## $fetch

For client-side only requests or manual control.

### Basic Usage

```typescript
// ✅ Simple GET
const users = await $fetch('/api/users')

// ✅ POST with body
const newUser = await $fetch('/api/users', {
  method: 'POST',
  body: { name: 'John', email: 'john@example.com' }
})

// ✅ With headers
const data = await $fetch('/api/protected', {
  headers: {
    'Authorization': `Bearer ${token}`
  }
})
```

### Event Handlers

```typescript
const handleSubmit = async () => {
  loading.value = true

  try {
    const result = await $fetch('/api/submit', {
      method: 'POST',
      body: formData.value
    })

    // Handle success
    showSuccess('Submitted successfully')
  } catch (error) {
    // Handle error
    showError('Submission failed')
  } finally {
    loading.value = false
  }
}
```

### TypeScript Support

```typescript
interface ApiResponse<T> {
  data: T
  message: string
}

// ✅ Type-safe $fetch
const response = await $fetch<ApiResponse<User>>('/api/user/profile')
// response is ApiResponse<User>
```

## Error Handling

### useFetch Error Handling

```typescript
const { data, error } = await useFetch('/api/users')

// ✅ Check for errors
if (error.value) {
  console.error('Fetch error:', error.value)
  // error.value contains FetchError with statusCode, message, etc.
}

// ✅ Use computed for error state
const hasError = computed(() => !!error.value)
const errorMessage = computed(() => error.value?.message || 'Unknown error')
```

### Global Error Handling

```typescript
const { data } = await useFetch('/api/users', {
  onResponseError({ response }) {
    // Handle specific status codes
    if (response.status === 401) {
      navigateTo('/login')
    } else if (response.status === 403) {
      showError('Access denied')
    } else {
      showError('Something went wrong')
    }
  }
})
```

### Try-Catch with $fetch

```typescript
const fetchUsers = async () => {
  try {
    const users = await $fetch('/api/users')
    return users
  } catch (error: any) {
    // FetchError from ofetch
    if (error.statusCode === 404) {
      console.log('Users not found')
    } else {
      console.error('Fetch failed:', error.message)
    }
    return []
  }
}
```

### Custom Error Composable

```typescript
export const useApiError = () => {
  const error = ref<string | null>(null)

  const handleError = (err: any) => {
    if (err.statusCode === 401) {
      error.value = 'Please log in'
      navigateTo('/login')
    } else if (err.statusCode === 403) {
      error.value = 'Access denied'
    } else if (err.statusCode === 404) {
      error.value = 'Resource not found'
    } else {
      error.value = err.message || 'Something went wrong'
    }
  }

  const clearError = () => {
    error.value = null
  }

  return {
    error: readonly(error),
    handleError,
    clearError
  }
}

// Usage
const { error, handleError } = useApiError()

const { data, error: fetchError } = await useFetch('/api/users')

watch(fetchError, (err) => {
  if (err) handleError(err)
})
```

## Caching & Refetching

### Manual Refresh

```typescript
const { data, refresh } = await useFetch('/api/users')

// Manually trigger refetch
const handleRefresh = async () => {
  await refresh()
  showSuccess('Data refreshed')
}
```

### Cache Management

```typescript
// Clear cached data
const clearCache = () => {
  clearNuxtData('users')  // Clear specific key
  clearNuxtData()         // Clear all cached data
}

// Access cached data
const getCached = () => {
  const cached = useNuxtData('users')
  return cached.data.value
}
```

### Dedupe Requests

```typescript
// Multiple calls with same key share the same request
const { data: data1 } = await useFetch('/api/users', { key: 'users' })
const { data: data2 } = await useFetch('/api/users', { key: 'users' })
// Only one request is made, both get the same data
```

### Custom Cache Strategy

```typescript
const { data } = await useFetch('/api/users', {
  key: 'users',
  getCachedData(key) {
    const cached = useNuxtData(key)
    // Use cache if less than 5 minutes old
    if (cached.data.value && Date.now() - cached.timestamp < 5 * 60 * 1000) {
      return cached.data.value
    }
    return undefined  // Fetch fresh data
  }
})
```

## Advanced Patterns

### Lazy Loading

```typescript
// ✅ Don't block navigation, fetch in background
const { data, pending } = await useLazyFetch('/api/heavy-data')

// Show loading state while fetching
<div v-if="pending">Loading...</div>
<div v-else>{{ data }}</div>
```

### Optimistic Updates

```typescript
const { data, refresh } = await useFetch('/api/todos')

const addTodo = async (todo: Todo) => {
  // Optimistic update
  const tempId = `temp-${Date.now()}`
  data.value = [...data.value, { ...todo, id: tempId }]

  try {
    // Save to server
    const newTodo = await $fetch('/api/todos', {
      method: 'POST',
      body: todo
    })

    // Replace temp with real data
    data.value = data.value.map(t =>
      t.id === tempId ? newTodo : t
    )
  } catch (error) {
    // Revert on error
    data.value = data.value.filter(t => t.id !== tempId)
    showError('Failed to add todo')
  }
}
```

### Polling

```typescript
const { data, refresh } = await useFetch('/api/status')

// Poll every 5 seconds
const { pause, resume } = useIntervalFn(() => {
  refresh()
}, 5000)

// Pause when component unmounts
onUnmounted(() => {
  pause()
})
```

### Pagination

```typescript
const page = ref(1)
const limit = ref(10)

const { data: response } = await useFetch('/api/users', {
  query: { page, limit }
})

const users = computed(() => response.value?.data || [])
const total = computed(() => response.value?.total || 0)
const totalPages = computed(() => Math.ceil(total.value / limit.value))

const nextPage = () => {
  if (page.value < totalPages.value) {
    page.value++  // Automatically refetches
  }
}

const prevPage = () => {
  if (page.value > 1) {
    page.value--  // Automatically refetches
  }
}
```

### Infinite Scroll

```typescript
const page = ref(1)
const allUsers = ref<User[]>([])

const { data, pending } = await useFetch('/api/users', {
  query: { page, limit: 20 },
  watch: [page]
})

// Append new data
watch(data, (newData) => {
  if (newData) {
    allUsers.value = [...allUsers.value, ...newData.data]
  }
})

const loadMore = () => {
  if (!pending.value) {
    page.value++
  }
}
```

## Best Practices Summary

1. **Use `useFetch` for simple API calls** - automatic SSR, caching, reactivity
2. **Use `useAsyncData` for complex logic** - multiple sources, custom processing
3. **Use `$fetch` for client-side actions** - form submissions, event handlers
4. **Always handle errors** - use error state and provide feedback
5. **Leverage reactive params** - automatic refetch on dependency changes
6. **Use keys for caching** - explicit keys for better cache control
7. **Transform data early** - use transform option to normalize responses
8. **Type your responses** - full TypeScript support for type safety
9. **Consider SSR behavior** - use `server: false` for client-only data
10. **Implement loading states** - use `pending` for better UX

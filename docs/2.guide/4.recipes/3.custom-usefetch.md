---
navigation.title: 'Custom useFetch'
title: Custom useFetch in Nuxt
description: How to create a custom fetcher for calling your external API in Nuxt 3.
---

When working with Nuxt, most of the time you are making the frontend and fetching an API made with another language (e.g. PHP with Laravel).

When we created the [`useFetch`](/docs/api/composables/use-fetch) composable and [`$fetch`](/docs/api/utils/dollarfetch) utility function, we made them immutable on purpose to avoid any side-effects. This is important to keep a consistent behaviour through your application and avoid any modules to break your API calls, for example.

Instead, we prefer that you create a custom fetcher for your API, which could also be useful if you have multiple APIs to call.

## Custom `$fetch`

First, we need to create a Nuxt plugin to create a custom `$fetch` instance.

::callout
`$fetch` is a configured instance of [ofetch](https://github.com/unjs/ofetch) which support adding the base URL of your Nuxt server as well a direct function calls during SSR (avoiding HTTP roundtrips).
::

Let's pretend here that:
- The main API is https://api.nuxt.com
- We are storing the JWT token in a session with [nuxt-auth-utils](https://github.com/atinux/nuxt-auth-utils)
- If the API responds with a `401` status code, we redirect the user to the `/login` page

```ts [plugins/api.ts]
export default defineNuxtPlugin(() => {
  const { session } = useUserSession()
  const $api = $fetch.create({
    baseURL: 'https://api.nuxt.com',
    onRequest({ request, options, error }) {
      if (session.value?.token) {
        // Add Authorization header
        options.headers = options.headers || {}
        options.headers.Authorization = `Bearer ${session.value?.token}`
      }
    },
    onResponseError({ response }) {
      if (response.status === 401) {
        return navigateTo('/login')
      }
    }
  })
  // Expose to useNuxtApp().$api
  return {
    provide: {
      api: $api
    }
  }
})
```

With this, we are able to use `$api` to make API calls directly in our Vue components:

```vue [app.vue]
<script setup>
const { $api } = useNuxtApp()
const { data: modules } = await useAsyncData('modules', () => $api('/modules'))
</script>
```

::callout
We are wrapping with [`useAsyncData`](/docs/api/composables/use-async-data) here in order to **avoid double data fetching when doing server-side rendering** (server & client on hydration).
::

## Custom `useFetch`

Now that we have `$api` with the logic we want, we can simplify the `useAsyncData` usage by creating a `useAPI` composable:

```ts [composables/useAPI.ts]
import type { UseFetchOptions } from 'nuxt/app';

export function useAPI<T>(
  url: string | (() => string),
  options: Omit<UseFetchOptions<T>, 'default'> & { default: () => T | Ref<T> },
) {
  return useFetch(url, {
    ...options,
    $fetch: useNuxtApp().$api,
  })
}
```

Now we can use our new composable and have a nice and clean component:

```vue [app.vue]
<script setup>
const { data: modules } = await useAPI('/modules')
</script>
```

::note
We are currently discussing with the core team to find a cleaner way to let you create a custom fetcher, see https://github.com/nuxt/nuxt/issues/14736.
::

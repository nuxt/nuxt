---
title: "Route Masking"
description: "Route masking allows you to display a different URL in the browser's address bar than the actual route being rendered. This is useful for modals, overlays, and other UI patterns where you want a shareable URL that differs from the internal route structure."
---

## What is Route Masking?

Route masking is a feature that allows you to display a different URL in the browser's address bar while rendering a different route internally. The "masked" URL is what users see and can share, while the "real" route determines what content is actually rendered.

This is particularly useful for:

- **Modal dialogs** - Show `/photos/5` in the URL while rendering `/photos/5/modal`
- **Overlay content** - Display `/posts/123` while rendering `/posts/123/comments`
- **Clean shareable URLs** - Hide implementation details like query parameters or nested routes
- **Progressive enhancement** - Allow deep-linking to specific UI states without exposing internal routing

## How It Works

When you navigate with a mask, Nuxt:

1. Navigates to the **real route** (renders the actual page component)
2. Updates the browser's URL to show the **masked URL**
3. Stores the real route in the browser's history state

This means:
- Users see and can copy the masked URL
- Browser back/forward buttons work correctly
- The real route is preserved for internal navigation

::note
When a masked URL is shared externally and opened in a new browser, the masked URL is loaded directly (since history state isn't shared). Design your routes so that masked URLs are valid entry points.
::

## Usage

There are three ways to use route masking in Nuxt:

### 1. Using `navigateTo`

The most flexible approach - use the `mask` option when navigating programmatically:

```vue [app/pages/photos/[id].vue]
<script setup lang="ts">
const route = useRoute()

async function openModal() {
  await navigateTo(`/photos/${route.params.id}/modal`, {
    mask: `/photos/${route.params.id}`,
  })
}
</script>

<template>
  <div>
    <img :src="`/photos/${route.params.id}.jpg`" />
    <button @click="openModal">View Details</button>
  </div>
</template>
```

When the button is clicked:
- The browser navigates to `/photos/5/modal` (real route)
- The URL bar shows `/photos/5` (masked URL)
- The modal page component is rendered

### 2. Using `<NuxtLink>`

For declarative navigation, use the `mask` prop on `<NuxtLink>`:

```vue [app/pages/posts/index.vue]
<template>
  <div>
    <NuxtLink
      v-for="post in posts"
      :key="post.id"
      :to="`/posts/${post.id}/comments`"
      :mask="`/posts/${post.id}`"
    >
      {{ post.title }} - View Comments
    </NuxtLink>
  </div>
</template>
```

### 3. Using `definePageMeta`

For route-level masking, define a mask directly in your page component:

```vue [app/pages/settings/modal.vue]
<script setup lang="ts">
definePageMeta({
  mask: '/settings',
})
</script>

<template>
  <div class="modal">
    <h1>Settings</h1>
    <!-- Modal content -->
  </div>
</template>
```

With this approach, any navigation to `/settings/modal` will automatically show `/settings` in the URL bar.

#### Dynamic Masks

You can also use a function to compute the mask dynamically based on the route:

```vue [app/pages/photos/[id]/edit.vue]
<script setup lang="ts">
definePageMeta({
  mask: (route) => `/photos/${route.params.id}`,
})
</script>
```

## Reload Behavior

By default, when a user reloads a page with a masked route, the mask is **preserved**. This means:
- URL stays as `/photos/5` (masked)
- Content renders from `/photos/5/modal` (real route)

### Unmasking on Reload

If you want the real URL to be shown after a page reload, use `unmaskOnReload: true`:

```ts
// With navigateTo
await navigateTo('/photos/5/modal', {
  mask: '/photos/5',
  unmaskOnReload: true,
})
```

```vue
<!-- With NuxtLink -->
<NuxtLink
  to="/photos/5/modal"
  mask="/photos/5"
  :unmask-on-reload="true"
>
  View Photo
</NuxtLink>
```

```vue
<!-- With definePageMeta -->
<script setup lang="ts">
definePageMeta({
  mask: '/photos',
  unmaskOnReload: true,
})
</script>
```

### Global Default

You can set the default reload behavior globally in your `nuxt.config.ts`:

```ts [nuxt.config.ts]
export default defineNuxtConfig({
  router: {
    options: {
      // Show real URL after reload by default
      unmaskOnReload: true,
    },
  },
})
```

## Browser Navigation

Route masking works seamlessly with browser navigation:

- **Back button**: Returns to the previous page (respects the actual navigation history)
- **Forward button**: Moves forward in history (restores masked state if applicable)
- **History state**: The real route is stored in `window.history.state` and restored automatically

## Common Patterns

### Modal Pattern

A common use case is showing a modal overlay while keeping a clean URL:

```
/products           → Product list page
/products/5         → Product detail (masked URL for modal)
/products/5/quick-view  → Actual modal route (real route)
```

```vue [app/pages/products/index.vue]
<script setup lang="ts">
const products = await $fetch('/api/products')

function openQuickView(id: number) {
  navigateTo(`/products/${id}/quick-view`, {
    mask: `/products/${id}`,
  })
}
</script>

<template>
  <div class="product-grid">
    <div v-for="product in products" :key="product.id">
      <img :src="product.image" />
      <button @click="openQuickView(product.id)">
        Quick View
      </button>
    </div>
  </div>
</template>
```

```vue [app/pages/products/[id]/quick-view.vue]
<script setup lang="ts">
const route = useRoute()
const product = await $fetch(`/api/products/${route.params.id}`)

function closeModal() {
  navigateTo('/products')
}
</script>

<template>
  <div class="modal-overlay" @click.self="closeModal">
    <div class="modal-content">
      <h1>{{ product.name }}</h1>
      <p>{{ product.description }}</p>
      <button @click="closeModal">Close</button>
    </div>
  </div>
</template>
```

### Tab or Panel Pattern

Show different content panels while maintaining a consistent URL:

```vue [app/pages/dashboard.vue]
<script setup lang="ts">
const activeTab = ref('overview')

function switchTab(tab: string) {
  navigateTo(`/dashboard/${tab}`, {
    mask: '/dashboard',
  })
}
</script>
```

## Best Practices

1. **Ensure masked URLs are valid routes**: Since shared URLs don't include history state, the masked URL should ideally resolve to a sensible default view.

2. **Use for UI state, not security**: Route masking is for UX improvement, not hiding sensitive routes. The real route is visible in browser developer tools.

3. **Consider SEO implications**: Search engines will index the URL they see. If the masked URL differs significantly from the content, consider your SEO strategy.

4. **Test browser navigation**: Always test that back/forward buttons work as expected with your masked routes.

## TypeScript Support

Route masking is fully type-safe. The `mask` option accepts:

```ts
// String path
mask: '/photos/5'

// With definePageMeta - string or function
definePageMeta({
  mask: '/photos',
  // or
  mask: (route) => `/photos/${route.params.id}`,
})
```

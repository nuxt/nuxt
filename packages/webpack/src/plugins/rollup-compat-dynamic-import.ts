import type { Compilation, Compiler, WebpackPluginInstance } from 'webpack'

const DYNAMIC_IMPORT_RE = /import\([^)]*\+\s*__webpack_require__[^+]*\)\.then/
const DYNAMIC_IMPORT_REPLACE_RE = /import\([^)]*\+\s*(__webpack_require__[^+]*)\)\.then/g

/**
 * Webpack plugin that generates rollup-compatible dynamic imports.
 * This plugin uses webpack's native compilation hooks to override dynamic import generation
 * and create rollup-compatible code directly during webpack's compilation process.
 */
export class RollupCompatDynamicImportPlugin implements WebpackPluginInstance {
  apply (compiler: Compiler) {
    compiler.hooks.compilation.tap('RollupCompatDynamicImportPlugin', (compilation) => {
      compilation.hooks.processAssets.tapAsync({
        name: 'RollupCompatDynamicImportPlugin',
        stage: compiler.webpack.Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE,
      }, (assets, callback) => {
        try {
          const targetFiles = new Set<string>()

          for (const chunk of compilation.chunks) {
            // Include entry chunks and runtime chunks as they contain webpack runtime
            if (chunk.canBeInitial() || chunk.hasRuntime()) {
              for (const file of chunk.files || []) {
                targetFiles.add(file)
              }
            }
          }

          // Transform JavaScript files that contain dynamic imports
          for (const [filename, asset] of Object.entries(assets)) {
            if (!filename.endsWith('.js') && !filename.endsWith('.mjs') && !filename.endsWith('.cjs')) {
              continue
            }

            // Skip non-target chunks to improve performance
            if (!targetFiles.has(filename)) {
              continue
            }

            const source = asset.source()
            const originalCode = typeof source === 'string' ? source : source.toString()

            if (!DYNAMIC_IMPORT_RE.test(originalCode)) {
              continue
            }

            // Transform dynamic imports in this file
            const transformedCode = this.transformDynamicImports(originalCode)

            if (transformedCode !== originalCode) {
              assets[filename] = new compiler.webpack.sources.RawSource(transformedCode)
            }
          }

          // Generate helper file
          this.generateDynamicImportHelper(compilation)
          callback()
        } catch (error) {
          callback(error as Error)
        }
      },
      )
    })
  }

  private transformDynamicImports (source: string): string {
    let transformed = source
    let needsHelperImport = false

    // Transform webpack-style dynamic imports to rollup-compatible ones
    transformed = transformed.replace(DYNAMIC_IMPORT_REPLACE_RE, (match, filename) => {
      needsHelperImport = true
      // Generate a rollup-compatible dynamic import using the module ID
      return `_rollupDynamicImport(${filename}).then`
    })

    // Add import statement at the top if we made any transformations
    if (needsHelperImport && !transformed.includes('from "./_dynamic-import-helper.mjs"')) {
      const importStatement = 'import { _rollupDynamicImport } from "./_dynamic-import-helper.mjs";\n'
      transformed = importStatement + transformed
    }

    return transformed
  }

  private generateDynamicImportHelper (compilation: Compilation) {
    const chunks: string[] = []
    for (const chunk of compilation.chunks) {
      // Skip runtime chunks as they don't contain loadable modules
      if (chunk.hasRuntime()) {
        continue
      }

      const [filename] = Array.from(chunk.files || [])
      if (filename && (filename.endsWith('.js') || filename.endsWith('.mjs') || filename.endsWith('.cjs'))) {
        chunks.push(filename)
      }
    }

    if (chunks.length === 0) {
      return
    }

    // Generate the helper that provides rollup-compatible dynamic imports
    const helperContent = this.generateHelperContent(chunks)
    compilation.emitAsset(
      '_dynamic-import-helper.mjs',
      new compilation.compiler.webpack.sources.RawSource(helperContent),
    )
  }

  private generateHelperContent (chunks: string[]): string {
    return `
// Rollup-compatible dynamic import helper generated by webpack
// This helper enables rollup to consume webpack chunks directly

const chunkMap = {
${chunks
  .map(filename => `  ${JSON.stringify(filename)}: () => import(${JSON.stringify('./' + filename)})`)
  .join(',\n')}
}

// Dynamic import function that rollup can understand
export function _rollupDynamicImport(chunkId) {
  const chunk = chunkMap[chunkId]
  if (!chunk) {
    return Promise.reject(new Error(\`Chunk \${chunkId} not found in chunkMap. Available chunks: \${Object.keys(chunkMap).join(', ')}\`))
  }
  
  // Use actual dynamic import for the chunk
  return chunk()
}
`
  }
}
